
<div id="ipython-notebook">
    <div class="buttons">
        <button class="interact-button js-nbinteract-widget">
            Show Widgets
        </button>
        <a class="interact-button" href="http://data100.datahub.berkeley.edu/user-redirect/git-pull?repo=https://github.com/DS-100/textbook&subPath=notebooks/ch09/sql_basics.ipynb">Open on DataHub</a></div>
    




<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  style="display:none;"
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># HIDDEN</span>
<span class="c1"># Clear previously defined variables</span>
<span class="o">%</span><span class="k">reset</span> -f

<span class="c1"># Set directory for data loading to work properly</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~/notebooks/ch09&#39;</span><span class="p">))</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="The-Relational-Database-Model-and-SQL">The Relational Database Model and SQL<a class="anchor-link" href="#The-Relational-Database-Model-and-SQL">&#182;</a></h1></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Relational-Model">The Relational Model<a class="anchor-link" href="#The-Relational-Model">&#182;</a></h2><p>A <strong>database</strong> is an organized collection of data. A long time ago, data used to be stored in specialized data structures that were designed for specific tasks; for example, airlines might record flight bookings in a different format than how a bank managed an account ledger. This began to change in 1969 when Ted Codd introduced the relational model as a general method of storing data. In this system, data would be stored in two-dimensional tables called <strong>relations</strong>, consisting of individual observations in each row (commonly referred to as a <strong>tuple</strong>). Each tuple is a structured data item that represents the relationship between certain <strong>attributes</strong> (columns). Each attribute of a relation has a name and data type.</p>
<p>Consider the <code>purchases</code> relation below:</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><header><h4 align='center'>purchases</h4></header></p>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <td><b>name</b></td>
            <td><b>product</b></td>
            <td><b>retailer</b></td>
            <td><b>date purchased</b></td>
        </tr>
    </thead>
    <tr>
        <td>Samantha</td>
        <td>iPod</td>
        <td>Best Buy</td>
        <td>June 3, 2016</td>
    </tr>
    <tr>
        <td>Timothy</td>
        <td>Chromebook</td>
        <td>Amazon</td>
        <td>July 8, 2016</td>
    </tr>
    <tr>
        <td>Jason</td>
        <td>Surface Pro</td>
        <td>Target</td>
        <td>October 2, 2016</td>
    </tr>
</table></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In <code>purchases</code>, each tuple represents the relationship between the <code>name</code>, <code>product</code>, <code>retailer</code>, and <code>date purchased</code> attributes.</p>
<p>A relation's <em>schema</em> contains its column names, data types, and constraints. The schema of the <code>purchases</code> table states that the columns are <code>name</code>, <code>product</code>, <code>retailer</code>, and <code>date purchased</code>; it also states that each column contains text.</p>
<p>Let's take a look at another relation called <code>prices</code> that shows the price of certain gadgets at particular retail stores:</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><header><h4 align='center'>prices</h4></header></p>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <td><b>retailer</b></td>
            <td><b>product</b></td>
            <td><b>price</b></td>
        </tr>
    </thead>
    <tr>
        <td>Best Buy</td>
        <td>Galaxy S9</td>
        <td>719.00</td>
    </tr>
    <tr>
        <td>Best Buy</td>
        <td>iPod</td>
        <td>200.00</td>
    </tr>
    <tr>
        <td>Amazon</td>
        <td>iPad</td>
        <td>450.00</td>
    </tr>
    <tr>
        <td>Amazon</td>
        <td>Battery pack</td>
        <td>24.87</td>
    </tr>
    <tr>
        <td>Amazon</td>
        <td>Chromebook</td>
        <td>249.99</td>
    </tr>
    <tr>
        <td>Target</td>
        <td>iPod</td>
        <td>215.00</td>
    </tr>
    <tr>
        <td>Target</td>
        <td>Surface Pro</td>
        <td>799.00</td>
    </tr>
    <tr>
        <td>Target</td>
        <td>Google Pixel 2</td>
        <td>659.00</td>
    </tr>
    <tr>
        <td>Walmart</td>
        <td>Chromebook</td>
        <td>238.79</td>
    </tr>
</table></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can then reference both tables simultaneously to determine how much Sue, Joey, and Alice paid for their respective gadgets (assuming prices at each store stay constant over time). Together, the two tables form a <strong>relational database</strong>, which is a collection of one or more relations.
The schema of the database is the set of schemas of the relations in the database.</p>
<p>It might seem that relational databases are functionally very similar to <code>pandas</code> dataframes; however, there are several additional benefits that they provide:</p>
<ul>
<li>As noted above, databases allow us to ensure data consistency on particular columns; for example, we can enforce that a column <code>GPA</code> only contains floats between 0.0 and 4.0 .</li>
<li>Databases are much more scalable than <code>pandas</code> dataframes. While <code>pandas</code> dataframes can only be as large as a computer's RAM, databases can typically be as large as a computer's disk space which is often much larger than the available RAM.</li>
<li>Querying languages such as SQL are simple to learn, empowering more people to conduct data analysis without advanced programming knowledge.</li>
</ul></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="What-is-SQL?">What is SQL?<a class="anchor-link" href="#What-is-SQL?">&#182;</a></h2><p><strong>SQL</strong> (Structured Query Language) is a widespread programming language that has simple operations to define, logically organize, manipulate, and perform calculations on data stored in a relational database.</p>
<p>SQL is a declarative language. This means that the user only needs to specify <em>what</em> kind of data they want, not <em>how</em> to obtain it. An example is shown below, with an imperative example for comparison:</p>
<ul>
<li><strong>Declarative</strong>: I want a table with columns “x” and “y” constructed from tables “A” and ”B” where the values in “y” are greater than 100.00.</li>
<li><strong>Imperative</strong>: For each record in table “A” find the corresponding record in table “B”, then drop the records where “y” is less than or equal to 100, then return the ”x” and “y” values.</li>
</ul>
<p>For our purposes, we'll be executing SQL queries through Python. As we walk through the basics of SQL syntax, we'll also occasionally show <code>pandas</code> equivalents for comparison purposes.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Executing-SQL-Queries-through-pandas">Executing SQL Queries through <code>pandas</code><a class="anchor-link" href="#Executing-SQL-Queries-through-pandas">&#182;</a></h3><p>To execute SQL queries from Python, we'll need to create a local SQLite database using the <a href="http://docs.sqlalchemy.org/en/latest/core/tutorial.html">sqlalchemy</a> library. Then we can use the <code>pandas</code> function <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql.html">pd.read_sql</a> to execute SQL queries through this connection.</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">sqlalchemy</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>

<span class="c1"># Delete the database if it already exists</span>
<span class="n">dbfile</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;data100.db&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">dbfile</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">dbfile</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>

<span class="c1"># pd.read_sql takes in a parameter for a SQLite engine, which we create below</span>
<span class="n">sqlite_uri</span> <span class="o">=</span> <span class="s2">&quot;sqlite:///data100.db&quot;</span>
<span class="n">sqlite_engine</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="n">sqlite_uri</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">



<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">ModuleNotFoundError</span>                       Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-1-5579eff9ec7a&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-fg">----&gt; 1</span><span class="ansi-red-fg"> </span><span class="ansi-green-fg">import</span> sqlalchemy
<span class="ansi-green-intense-fg ansi-bold">      2</span> <span class="ansi-green-fg">from</span> pathlib <span class="ansi-green-fg">import</span> Path
<span class="ansi-green-intense-fg ansi-bold">      3</span> 
<span class="ansi-green-intense-fg ansi-bold">      4</span> <span class="ansi-red-fg"># Delete the database if it already exists</span>
<span class="ansi-green-intense-fg ansi-bold">      5</span> dbfile <span class="ansi-blue-fg">=</span> Path<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">&#34;data100.db&#34;</span><span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">ModuleNotFoundError</span>: No module named &#39;sqlalchemy&#39;

<span class="ansi-red-fg">---------------------------------------------------------------------------</span><span class="ansi-green-fg">
NOTE: If your import is failing due to a missing package, you can
manually install dependencies using either !pip or !apt.

To view examples of installing some common dependencies, click the
&#34;Open Examples&#34; button below.
</span><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#HIDDEN</span>

<span class="c1"># Verify that there are no tables present in the file</span>
<span class="n">sqlite_engine</span><span class="o">.</span><span class="n">table_names</span><span class="p">()</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">



<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-2-72115ee59ef1&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-fg">----&gt; 1</span><span class="ansi-red-fg"> </span>sqlite_engine<span class="ansi-blue-fg">.</span>table_names<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">NameError</span>: name &#39;sqlite_engine&#39; is not defined</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  style="display:none;"
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># HIDDEN</span>

<span class="c1"># Creating a table</span>
<span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">CREATE TABLE prices(</span>
<span class="s2">    retailer TEXT,</span>
<span class="s2">    product TEXT,</span>
<span class="s2">    price FLOAT);</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sqlite_engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  style="display:none;"
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># HIDDEN</span>

<span class="c1"># Inserting records into the table</span>
<span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">INSERT INTO prices VALUES </span>
<span class="s2">  (&#39;Best Buy&#39;, &#39;Galaxy S9&#39;, 719.00),</span>
<span class="s2">  (&#39;Best Buy&#39;, &#39;iPod&#39;, 200.00),</span>
<span class="s2">  (&#39;Amazon&#39;, &#39;iPad&#39;, 450.00),</span>
<span class="s2">  (&#39;Amazon&#39;, &#39;Battery pack&#39;,  24.87),</span>
<span class="s2">  (&#39;Amazon&#39;, &#39;Chromebook&#39;, 249.99),</span>
<span class="s2">  (&#39;Target&#39;, &#39;iPod&#39;, 215.00),</span>
<span class="s2">  (&#39;Target&#39;, &#39;Surface Pro&#39;, 799.00),</span>
<span class="s2">  (&#39;Target&#39;, &#39;Google Pixel 2&#39;, 659.00),</span>
<span class="s2">  (&#39;Walmart&#39;, &#39;Chromebook&#39;, 238.79);</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sqlite_engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Verify that the prices relation is in the database</span>

<span class="n">sqlite_engine</span><span class="o">.</span><span class="n">table_names</span><span class="p">()</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To compare SQL and <code>pandas</code>, we create an identical dataframe in <code>pandas</code>:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s1">&#39;Best Buy&#39;</span><span class="p">,</span> <span class="s1">&#39;Galaxy S9&#39;</span><span class="p">,</span> <span class="mf">719.00</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Best Buy&#39;</span><span class="p">,</span> <span class="s1">&#39;iPod&#39;</span><span class="p">,</span> <span class="mf">200.00</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Amazon&#39;</span><span class="p">,</span> <span class="s1">&#39;iPad&#39;</span><span class="p">,</span> <span class="mf">450.00</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Amazon&#39;</span><span class="p">,</span> <span class="s1">&#39;Battery pack&#39;</span><span class="p">,</span> <span class="mf">24.87</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Amazon&#39;</span><span class="p">,</span> <span class="s1">&#39;Chromebook&#39;</span><span class="p">,</span> <span class="mf">249.99</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Target&#39;</span><span class="p">,</span> <span class="s1">&#39;iPod&#39;</span><span class="p">,</span> <span class="mf">215.00</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Target&#39;</span><span class="p">,</span> <span class="s1">&#39;Surface Pro&#39;</span><span class="p">,</span> <span class="mf">799.00</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Target&#39;</span><span class="p">,</span> <span class="s1">&#39;Google Pixel 2&#39;</span><span class="p">,</span> <span class="mf">659.00</span><span class="p">],</span>
                   <span class="p">[</span><span class="s1">&#39;Walmart&#39;</span><span class="p">,</span> <span class="s1">&#39;Chromebook&#39;</span><span class="p">,</span> <span class="mf">238.79</span><span class="p">]],</span>
                 <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;retailer&#39;</span><span class="p">,</span> <span class="s1">&#39;product&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">])</span>
<span class="n">df</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>product</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Best Buy</td>
      <td>Galaxy S9</td>
      <td>719.00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Best Buy</td>
      <td>iPod</td>
      <td>200.00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Amazon</td>
      <td>iPad</td>
      <td>450.00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Amazon</td>
      <td>Battery pack</td>
      <td>24.87</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Amazon</td>
      <td>Chromebook</td>
      <td>249.99</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Target</td>
      <td>iPod</td>
      <td>215.00</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Target</td>
      <td>Surface Pro</td>
      <td>799.00</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Target</td>
      <td>Google Pixel 2</td>
      <td>659.00</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Walmart</td>
      <td>Chromebook</td>
      <td>238.79</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We now have a SQL table called <code>prices</code> (which we can connect through using <code>sqlite_engine</code>), as well as a <code>pandas</code> dataframe <code>df</code>.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="SQL-Syntax">SQL Syntax<a class="anchor-link" href="#SQL-Syntax">&#182;</a></h2><p>All SQL queries take the general form below:</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="p">[</span><span class="k">DISTINCT</span><span class="p">]</span> <span class="o">&lt;</span><span class="k">column</span> <span class="n">expression</span> <span class="n">list</span><span class="o">&gt;</span>
<span class="k">FROM</span> <span class="o">&lt;</span><span class="n">relation</span><span class="o">&gt;</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="o">&lt;</span><span class="n">predicate</span><span class="o">&gt;</span><span class="p">]</span>
<span class="p">[</span><span class="k">GROUP</span> <span class="k">BY</span> <span class="o">&lt;</span><span class="k">column</span> <span class="n">list</span><span class="o">&gt;</span><span class="p">]</span>
<span class="p">[</span><span class="k">HAVING</span> <span class="o">&lt;</span><span class="n">predicate</span><span class="o">&gt;</span><span class="p">]</span>
<span class="p">[</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="o">&lt;</span><span class="k">column</span> <span class="n">list</span><span class="o">&gt;</span><span class="p">]</span>
<span class="p">[</span><span class="k">LIMIT</span> <span class="o">&lt;</span><span class="nb">number</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
<p>Note that:</p>
<ol>
<li><strong>Everything in [square brackets] is optional.</strong> A valid SQL query only needs a <code>SELECT</code> and a <code>FROM</code> statement.</li>
<li><strong>SQL SYNTAX IS GENERALLY WRITTEN IN CAPITAL LETTERS.</strong> Although capitalization isn't required, it is common practice to write SQL syntax in capital letters. It also helps to visually structure your query for other people to read.</li>
<li><code>FROM</code> query blocks can reference one or more tables, although in this section we will only look at one table at a time. See the section on SQL joins for more.</li>
</ol></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="SELECT-and-FROM">SELECT and FROM<a class="anchor-link" href="#SELECT-and-FROM">&#182;</a></h3><p>The two mandatory statements in a SQL query are:</p>
<ul>
<li><code>SELECT</code> indicates the columns that we want to view.</li>
<li><code>FROM</code> indicates the tables from which we are selecting these columns.</li>
</ul>
<p>To display the entire <code>prices</code> table, we run:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT * </span>
<span class="s2">FROM prices</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>product</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Best Buy</td>
      <td>Galaxy S9</td>
      <td>719.00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Best Buy</td>
      <td>iPod</td>
      <td>200.00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Amazon</td>
      <td>iPad</td>
      <td>450.00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Amazon</td>
      <td>Battery pack</td>
      <td>24.87</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Amazon</td>
      <td>Chromebook</td>
      <td>249.99</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Target</td>
      <td>iPod</td>
      <td>215.00</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Target</td>
      <td>Surface Pro</td>
      <td>799.00</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Target</td>
      <td>Google Pixel 2</td>
      <td>659.00</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Walmart</td>
      <td>Chromebook</td>
      <td>238.79</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>SELECT *</code> returns every column in the original relation. To display the retailers that are represented in <code>prices</code>, we add the <code>retailer</code> column to the <code>SELECT</code> statement.</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT retailer</span>
<span class="s2">FROM prices</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">



<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-3-51b89315a6d2&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-intense-fg ansi-bold">      3</span> FROM prices
<span class="ansi-green-intense-fg ansi-bold">      4</span> &#34;&#34;&#34;
<span class="ansi-green-fg">----&gt; 5</span><span class="ansi-red-fg"> </span>pd<span class="ansi-blue-fg">.</span>read_sql<span class="ansi-blue-fg">(</span>sql_expr<span class="ansi-blue-fg">,</span> sqlite_engine<span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">NameError</span>: name &#39;pd&#39; is not defined</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If we want a list of unique retailers, we include the <code>DISTINCT</code> keyword to omit repeated values.</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">jsql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT DISTINCT retailer</span>
<span class="s2">FROM prices</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Best Buy</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Amazon</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Target</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Walmart</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This would be the functional equivalent of the following <code>pandas</code> code:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;retailer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">





<div class="output_text output_subarea output_execute_result">
<pre>array([&#39;Best Buy&#39;, &#39;Amazon&#39;, &#39;Target&#39;, &#39;Walmart&#39;], dtype=object)</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>SQL has a wide range of functions that can be applied to each attribute in the <code>SELECT</code> list. For example, most SQL engines include comparison operators, mathematical functions and operators, and string functions and operators. (The complete list of built in PostgreSQL functions is available <a href="https://www.postgresql.org/docs/9.2/static/functions.html">here</a>.)</p>
<p>The following code converts all retailer names to uppercase and cuts product prices in half (a 50% discount!).</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT UPPER(retailer) AS retailer_caps, product, price / 2 AS half_price</span>
<span class="s2">FROM prices</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Notice that we can <strong>alias</strong> the columns (assign another name) with AS so that the columns appear with this new name in the ouptut table. This does not modify the names of the columns in the source relation.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="WHERE">WHERE<a class="anchor-link" href="#WHERE">&#182;</a></h3><p>Including a <code>WHERE</code> clause allows us to specify certain constraints for the returned data; these constraints are often referred to as <strong>predicates</strong>. For example, to retrieve only gadgets that are under $500:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT *</span>
<span class="s2">FROM prices</span>
<span class="s2">WHERE price &lt; 500</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">



<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-5-b4fc02e3dd44&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-intense-fg ansi-bold">      4</span> WHERE price <span class="ansi-blue-fg">&lt;</span> <span class="ansi-cyan-fg">500</span>
<span class="ansi-green-intense-fg ansi-bold">      5</span> &#34;&#34;&#34;
<span class="ansi-green-fg">----&gt; 6</span><span class="ansi-red-fg"> </span>pd<span class="ansi-blue-fg">.</span>read_sql<span class="ansi-blue-fg">(</span>sql_expr<span class="ansi-blue-fg">,</span> sqlite_engine<span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">NameError</span>: name &#39;pd&#39; is not defined</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can also use the operators <code>AND</code>, <code>OR</code>, and <code>NOT</code> to further constrain our SQL query. Suppose we want to buy something on Amazon because we have a gift card, but we're not interested in a battery pack or anything above $300:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT *</span>
<span class="s2">FROM prices</span>
<span class="s2">WHERE retailer = &#39;Amazon&#39;</span>
<span class="s2">    AND NOT product = &#39;Battery pack&#39;</span>
<span class="s2">    AND price &lt;= 300</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>product</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Amazon</td>
      <td>Chromebook</td>
      <td>249.99</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The equivalent operation in <code>pandas</code> is:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;retailer&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Amazon&#39;</span><span class="p">)</span> 
   <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;product&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Battery pack&#39;</span><span class="p">)</span>
   <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">300</span><span class="p">)]</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>product</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>Amazon</td>
      <td>Chromebook</td>
      <td>249.99</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There's a subtle difference that's worth noting: the index of the Chromebook in the SQL query is 0, whereas the corresponding index in the dataframe is 4. This is because SQL queries always return a new table with indices counting up from 0, whereas <code>pandas</code> subsets a portion of the dataframe <code>df</code> and returns it with the original indices. We can use <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html">pd.DataFrame.reset_index</a> to reset the indices in <code>pandas</code>.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Aggregate-Functions">Aggregate Functions<a class="anchor-link" href="#Aggregate-Functions">&#182;</a></h3><p>So far, we've only worked with data from the existing rows in the table; that is, all of our returned tables have been some subset of the entries found in the table. But to conduct data analysis, we'll want to compute aggregate values over our data. In SQL, these are called <strong>aggregate functions</strong>.</p>
<p>If we want to find the average price of all gadgets in the <code>prices</code> relation:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT AVG(price) AS avg_price</span>
<span class="s2">FROM prices</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>avg_price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>395.072222</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Equivalently, in <code>pandas</code>:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">





<div class="output_text output_subarea output_execute_result">
<pre>395.0722222222222</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A complete list of PostgreSQL aggregate functions can be found <a href="https://www.postgresql.org/docs/9.2/static/functions.html">here</a>. Though we're using PostgreSQL as our primary version of SQL in this class, it's worth keeping in mind that there are many other variations of SQL (MySQL, SQLite, etc.) that may adhere to slightly different function names and available functions.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="GROUP-BY-and-HAVING">GROUP BY and HAVING<a class="anchor-link" href="#GROUP-BY-and-HAVING">&#182;</a></h3><p>With aggregate functions, we can execute more complicated SQL queries. To operate on more granular aggregate data, we can use the following two clauses:</p>
<ul>
<li><code>GROUP BY</code> takes a list of columns and groups the table like the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html">pd.DataFrame.groupby</a> function in <code>pandas</code>.</li>
<li><code>HAVING</code> is functionally similar to <code>WHERE</code>, but is used exclusively to apply predicates to aggregated data. (Note that in order to use <code>HAVING</code>, it must be preceded by a <code>GROUP BY</code> clause.)</li>
</ul>
<p><strong>Important</strong>: When using GROUP BY, all columns in the SELECT list must be either listed in the GROUP BY clause or have an aggregate function applied to them.</p>
<p>We can use these statements to find the maximum price at each retailer.</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT retailer, MAX(price) as max_price</span>
<span class="s2">FROM prices</span>
<span class="s2">GROUP BY retailer</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>max_price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Amazon</td>
      <td>450.00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Best Buy</td>
      <td>719.00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Target</td>
      <td>799.00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Walmart</td>
      <td>238.79</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's say we have a client with expensive taste, and we only consider retailers that sell gadgets over $700. Note that we must use <code>HAVING</code> to define predicates on aggregated columns; we can't use <code>WHERE</code> to filter an aggregated column. To compute a list of retailers and accompanying prices that satisfy our needs, we run:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT retailer, MAX(price) as max_price</span>
<span class="s2">FROM prices</span>
<span class="s2">GROUP BY retailer</span>
<span class="s2">HAVING max_price &gt; 700</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>max_price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Best Buy</td>
      <td>719.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Target</td>
      <td>799.0</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Only Best Buy and Target seem to match our lavish needs. For comparison, we recreate the same table in <code>pandas</code>:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">max_price_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;retailer&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">max_price_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">max_price_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">700</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]]</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
    </tr>
    <tr>
      <th>retailer</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Best Buy</th>
      <td>719.0</td>
    </tr>
    <tr>
      <th>Target</th>
      <td>799.0</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="ORDER-BY-and-LIMIT">ORDER BY and LIMIT<a class="anchor-link" href="#ORDER-BY-and-LIMIT">&#182;</a></h3><p>These clauses allow us to control the presentation of the data:</p>
<ul>
<li><code>ORDER BY</code> lets us present the data in lexicographic order of column values. By default, ORDER BY uses ascending order (<code>ASC</code>), but we can specify descending order using <code>DESC</code>.</li>
<li><code>LIMIT</code> controls how many tuples are displayed.</li>
</ul>
<p>Let's display the three cheapest items in our <code>prices</code> table:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sql_expr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">SELECT *</span>
<span class="s2">FROM prices</span>
<span class="s2">ORDER BY price ASC</span>
<span class="s2">LIMIT 3</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="n">sql_expr</span><span class="p">,</span> <span class="n">sqlite_engine</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>product</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Amazon</td>
      <td>Battery pack</td>
      <td>24.87</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Best Buy</td>
      <td>iPod</td>
      <td>200.00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Target</td>
      <td>iPod</td>
      <td>215.00</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that we didn't have to include the <code>ASC</code> keyword (since <code>ORDER BY</code> returns data in ascending order by default).
For comparison, in <code>pandas</code>:</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>retailer</th>
      <th>product</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3</th>
      <td>Amazon</td>
      <td>Battery pack</td>
      <td>24.87</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Best Buy</td>
      <td>iPod</td>
      <td>200.00</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Target</td>
      <td>iPod</td>
      <td>215.00</td>
    </tr>
  </tbody>
</table></div></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Again, we see that the indices are out of order in the <code>pandas</code> dataframe. As before, <code>pandas</code> returns a view on our dataframe <code>df</code>, whereas SQL is displaying a new table that matches our requirements each time that we execute a query.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Conceptual-SQL-Evaluation">Conceptual SQL Evaluation<a class="anchor-link" href="#Conceptual-SQL-Evaluation">&#182;</a></h3><p>Clauses in a SQL query are executed in a specific order. It is important to know this order because it differs from the order that the clauses are written in a SQL query. From first executed to last:</p>
<ol>
<li><code>FROM</code>: One or more source tables (see the next section to learn about joins)</li>
<li><code>WHERE</code>: Apply selection qualifications (eliminate rows)</li>
<li><code>GROUP BY</code>: Form groups and aggregate</li>
<li><code>HAVING</code>: Eliminate groups</li>
<li><code>SELECT</code>: Project away columns (just keep those used in <code>SELECT</code>, <code>GROUP BY</code>, and <code>HAVING</code>)</li>
<li><code>[DISTINCT]</code>: Eliminate duplicates</li>
</ol>
<p><strong><code>WHERE</code> vs. <code>HAVING</code></strong>: Since the <code>WHERE</code> clause is processed before applying <code>GROUP BY</code>, the <code>WHERE</code> clause cannot make use of aggregated values. To define predicates based on aggregated values, we must use <code>HAVING</code>.</p></div></div></div></div>
